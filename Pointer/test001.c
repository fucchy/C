/*
 * ポインタの勉強
 * filename:test001.c
 * 
 * ポインタの使い方:
 * (1)宣言
 * (2)アドレスの設定
 * (3)使用
 *
 */

#include<stdio.h>
#include<stdlib.h>

int main(int argc,char *argv[]){
	int a; // 変数aの型宣言
	int * p; // ポインタpの型宣言とポインタ宣言。int *pでも、int* pでも、int * pでもいい。要は、間接演算子が宣言されている事が大事。
	// int*という型名があるのでもなく、*pという変数名があるのでもない。ポインタ宣言されたpがあるという感じ?

	a = 100; // 変数aに整数値100を代入
	p = &a; // 変数aのアドレスをポインタpに代入

	printf(" a = %d\n",a); // 変数pに代入されている値を表示
	printf("&a = %p\n",(void *)&a); // 変数aのアドレスを表示。p=&aなので、ポインタpのアドレスと同じ値のはず。
	printf("*p = %d\n",*p); // ポインタpの参照先(a)の値を表示
	printf(" p = %p\n",(void *)p); // ポインタpのアドレスを表示

	// *p++; // これだと怒られた。なんで？
	//*(p++); // これと同じエラーだったので、このように評価されてる？
	// 間接演算子(単項*演算子)と後置増分演算子(後置++演算子)との間で優先順位を比較すると、
	// 後置増分演算子の方が先に評価されてしまう。
	(*p)++; // ポインタpの参照先に1を加える

    printf("-----\n");
	printf(" a = %d\n",a); // ポインタpの参照先がaなので、aの値が+1
	printf("&a = %p\n",(void *)&a);
	printf("*p = %d\n",*p); // (*p)++で*pの中に+1がされたので、101になるはず
	printf(" p = %p\n",(void *)p);

	return EXIT_SUCCESS;
}

